<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="山上掏金">
<meta property="og:url" content="https://chlyzzo.github.io/index.html">
<meta property="og:site_name" content="山上掏金">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="山上掏金">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chlyzzo.github.io/"/>





  <title>山上掏金</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">山上掏金</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天早上起床是为了比昨天更快乐，掏金者新的一天是零的开始.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chlyzzo.github.io/2017/06/02/flink在yarn上搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wenxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山上掏金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/02/flink在yarn上搭建/" itemprop="url">Flink在YARN上搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-02T22:26:59+08:00">
                2017-06-02 22:26:59
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flink/" itemprop="url" rel="index">
                    <span itemprop="name">Flink</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flink/YARN/" itemprop="url" rel="index">
                    <span itemprop="name">YARN</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>翻译Flink官网文档，Flink在YARN集群提交job，调试，以及命令行提交格式。最后，是Flink与YARN的交互分析。<br>文中会夹杂一些实践经验，读者可以参考或者进行实践，完善。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="在YARN上启动一个长期的Flink集群"><a href="#在YARN上启动一个长期的Flink集群" class="headerlink" title="在YARN上启动一个长期的Flink集群"></a>在YARN上启动一个长期的Flink集群</h3><p>启动一个拥有4个Task Manager的yarn会话，每个Task Manager有4gb的堆内存:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 从flink下载页获取haddoop2包</span></div><div class="line"><span class="comment"># http://flink.apache.org/downloads.html</span></div><div class="line">curl -O &lt;flink_hadoop2_download_url&gt;</div><div class="line">tar xvzf flink-&#123;&#123; site.version &#125;&#125;-bin-hadoop2.tgz</div><div class="line"><span class="built_in">cd</span> flink-&#123;&#123; site.version &#125;&#125;/</div><div class="line">./bin/yarn-session.sh -n 4 -jm 1024 -tm 4096</div></pre></td></tr></table></figure>
<p>特别指出，-s参数表示每个Task Manager上可用的处理槽（processing slot）数量。我们建议把槽数量设置成每个机器处理器的个数。<br>一旦会话被启动，你可以使用./bin/flink工具提交任务到集群上。</p>
<h3 id="在YARN上运行一个Flink的任务"><a href="#在YARN上运行一个Flink的任务" class="headerlink" title="在YARN上运行一个Flink的任务"></a>在YARN上运行一个Flink的任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 从flink下载页获取haddoop2包</span></div><div class="line"><span class="comment"># http://flink.apache.org/downloads.html</span></div><div class="line">curl -O &lt;flink_hadoop2_download_url&gt;</div><div class="line">tar xvzf flink-&#123;&#123; site.version &#125;&#125;-bin-hadoop2.tgz</div><div class="line"><span class="built_in">cd</span> flink-&#123;&#123; site.version &#125;&#125;/</div><div class="line">./bin/flink run -m yarn-cluster -yn 4 -yjm 1024 -ytm 4096 ./examples/batch/WordCount.jar</div></pre></td></tr></table></figure>
<h2 id="Flink-YARN-会话"><a href="#Flink-YARN-会话" class="headerlink" title="Flink YARN 会话"></a>Flink YARN 会话</h2><p>Apache <a href="http://hadoop.apache.org/" target="_blank" rel="external">Hadoop YARN</a>是一个资源管理框架，允许一个集群上运行多种分布式应用程序。<br>Flink 可以和其他应用程序一起在 YARN 上运行。如果已经启动了YARN，用户就不需再启动或安装任何东西。</p>
<p><strong>要求</strong></p>
<ul>
<li>Apache Hadoop版本至少2.2</li>
<li>HDFS（Hadoop分布式文件系统）（或其他由Hadoop支持的分布式文件系统）.</li>
</ul>
<p>如果你在使用Flink YARN客户端有问题时，请看此<a href="http://flink.apache.org/faq.html#yarn-deployment" target="_blank" rel="external">问题论坛</a>.</p>
<h3 id="启动Flink会话"><a href="#启动Flink会话" class="headerlink" title="启动Flink会话"></a>启动Flink会话</h3><p>跟随以下介绍学习怎样在你的yran集群中启动一个Flink会话.</p>
<p>一个会话将启动所有Flink服务（JobManager and TaskManagers），这样你就可以提交程序给集群运行，记住在一个会话中可以运行<br>多个程序。</p>
<h4 id="下载Flink"><a href="#下载Flink" class="headerlink" title="下载Flink"></a>下载Flink</h4><p>下载一个Hadoop版本大于2的Flink包，可从<a href="http://flink.apache.org/downloads.html" target="_blank" rel="external">该下载页</a>获得。它包含了所需的文件。<br>提取下载包的方法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar xvzf flink-1.4-SNAPSHOT-bin-hadoop2.tgz</div><div class="line"><span class="built_in">cd</span> flink-1.4-SNAPSHOT/</div></pre></td></tr></table></figure>
<h4 id="启动一个会话"><a href="#启动一个会话" class="headerlink" title="启动一个会话"></a>启动一个会话</h4><p>使用如下命令来启动一个会话，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/yarn-session.sh</div></pre></td></tr></table></figure>
<p>该命令的概览如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">使用:</div><div class="line">   要求:</div><div class="line">     -n,--container &lt;arg&gt;   YARN上容器个数 (=taskmanager的个数）</div><div class="line">   可选参数</div><div class="line">     -D &lt;arg&gt;                        动态属性</div><div class="line">     <span class="_">-d</span>,--detached                   启动分离（提交job的机器与yarn集群分离）</div><div class="line">     -jm,--jobManagerMemory &lt;arg&gt;    JobManager Container内存大小 [<span class="keyword">in</span> MB]</div><div class="line">     -nm,--name                      自定义提交job的名字</div><div class="line">     -q,--query                      展示yarn的可用资源，内存和核数 (memory, cores)</div><div class="line">     -qu,--queue &lt;arg&gt;               指定yarn队列.</div><div class="line">     <span class="_">-s</span>,--slots &lt;arg&gt;                每个TaskManager的处理槽数</div><div class="line">     -tm,--taskManagerMemory &lt;arg&gt;   每个TaskManager Container的内存大小 [<span class="keyword">in</span> MB]</div><div class="line">     -z,--zookeeperNamespace &lt;arg&gt;   在高可用模式下，命名空间为zookeeper创建子路径</div></pre></td></tr></table></figure>
<p>请注意，客户端需要 YARN_CONF_DIR 或 HADOOP_CONF_DIR 环境变量被设置好，可以通过它读取 YARN 和 HDFS 的配置。</p>
<p><strong>例子:</strong> 如下命令分配10个Task Manager，每个拥有8GB内存和32个处理槽：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/yarn-session.sh -n 10 -tm 8192 <span class="_">-s</span> 32</div></pre></td></tr></table></figure>
<p>系统将使用conf/flink-conf.yaml下的配置。如果你想更改一些配置，请参考配置手册。</p>
<p>Flink在YARN上，将会重写如下配置参数的值，jobmanager.rpc.address（因为Job Manager总是分配在不同机器上），<br>taskmanager.tmp.dirs（我们使用YARN给的tmp目录），parallelism.default（如果槽个数被指定）。</p>
<p>如果你不想改变配置文件来设置配置参数，这里有个方法来获得动态属性，通过-D标示。这样可以通过以下方法来传递参数，<br>-Dfs.overwrite-files=true -Dtaskmanager.network.memory.min=536346624.</p>
<p>例子将请求启动11个容器（尽管仅需10个容器），因为这需要额外的1个容器给ApplicationMaster and Job Manager.</p>
<p>只要Flink部署在YARN集群上，它会让你看到Job Manager间的连接细节。</p>
<p>通过停止unix进程（使用CTRL+C命令）来停止YARN会话，或者在客户端输入stop。</p>
<p>Flink在YARN上仅仅启动所请求的容器，如果YARN集群上有足够的可用资源。大多YARN调度程序为容器，计算请求内存，一些还计算vcores数量。</p>
<p>默认情况，vcores数量等于处理节点数（-s），yarn.containers.vcores允许自定义值重写vcores数量。</p>
<h4 id="隔离YARN会话"><a href="#隔离YARN会话" class="headerlink" title="隔离YARN会话"></a>隔离YARN会话</h4><p>如果你不想保持Flink YARN客户端一直运行，可以启动隔离YARN会话来达到目的。这个参数即是-d或–detached。<br>在此情况下，Flink YARN客户端将仅提交Flink到集群中，然后关闭连接。注意的是在此情况下，将不可能使用Flink来停止YARN会话。<br>使用YARN命令（yarn application –kill <appid>）来停止YARN会话。</appid></p>
<h4 id="关联现有会话"><a href="#关联现有会话" class="headerlink" title="关联现有会话"></a>关联现有会话</h4><p>使用如下命令启动一个会话</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/yarn-session.sh</div></pre></td></tr></table></figure>
<p>这个命令将展示如下概览：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">参数必须:</div><div class="line">     -id,--applicationId &lt;yarnAppId&gt; YARN application Id</div></pre></td></tr></table></figure>
<p>如之前所述，YARN_CONF_DIR 或 HADOOP_CONF_DIR环境变量需设置能让YARN 和 HDFS 配置读取到。</p>
<p><strong>例子:</strong> 假设以下命令关联一个正运行的Flink YARN会话application_1463870264508_0029</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/yarn-session.sh -id application_1463870264508_0029</div></pre></td></tr></table></figure>
<p>使用YARN 资源管理器来决定Job Manager的RPC端口从而关联一个运行的会话。<br>停止YARN会话可通过停止unix进程（CTRL+C）或通过再客户端输入stop。</p>
<h3 id="提交job到Flink"><a href="#提交job到Flink" class="headerlink" title="提交job到Flink"></a>提交job到Flink</h3><p>使用如下命令提交一个Flink程序到YARN集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/flink</div></pre></td></tr></table></figure>
<p>请参考命令行客户端文档。<br>命令行帮助菜单如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[...]</div><div class="line">run操作编译和运行程序。</div><div class="line"></div><div class="line"> 语法: run [OPTIONS] &lt;jar-file&gt; &lt;arguments&gt;</div><div class="line">  <span class="string">"run"</span> 操作参数:</div><div class="line">     -c,--class &lt;classname&gt;           程序入口的类 (<span class="string">"main"</span>方法 或 <span class="string">"getPlan()"</span> 方法.jar文件没有在其清单中指定类才需要.</div><div class="line">     -m,--jobmanager &lt;host:port&gt;      连接Job Manager（master）的地址. 使用此参数连接一个不同的job管理器，而不是在配置中指明.</div><div class="line">     -p,--parallelism &lt;parallelism&gt;   运行程序的并行度. 这个可选参数可覆盖配置中指定的默认值。</div></pre></td></tr></table></figure>
<p>用run操作提交一个job到YARN上。客户端可以决定Job Manager的地址。罕见情况下，你可使用-m参数指定Job Manager地址。Job Manager地址可在YARN控制台见到。</p>
<p><strong>例子</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget -O LICENSE-2.0.txt http://www.apache.org/licenses/LICENSE-2.0.txt</div><div class="line">hadoop fs -copyFromLocal LICENSE-2.0.txt hdfs:/// ...</div><div class="line">./bin/flink run ./examples/batch/WordCount.jar \</div><div class="line">        hdfs:///..../LICENSE-2.0.txt hdfs:///.../wordcount-result.txt</div></pre></td></tr></table></figure>
<p>如果存在如下错误，请确保所有Task Manager已经启动:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> org.apache.flink.compiler.CompilerException:</div><div class="line">    Available instances could not be determined from job manager: Connection timed out.</div></pre></td></tr></table></figure>
<p>你可以在Job Manager的web接口中查看Task Manager的数量。接口的地址会在YARN会话的控制台中输出。<br>如果Task Manager一分钟内没有显示出，那么你应该在日志文件中检查错误在哪。</p>
<h2 id="在YARN上运行一个Flink-任务"><a href="#在YARN上运行一个Flink-任务" class="headerlink" title="在YARN上运行一个Flink 任务"></a>在YARN上运行一个Flink 任务</h2><p>上述文档描述了如何启动一个Flink集群在Hadoop YARN环境下。这也可以仅执行一个job而启动Flink在YARN下。<br>请注意客户端需要-yn值来设置Task Manager的数量。</p>
<p><strong><em>例子:</em></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/flink run -m yarn-cluster -yn 2 ./examples/batch/WordCount.jar</div></pre></td></tr></table></figure>
<p>在YARN会话下命令行 ./bin/flink tool是可选的，以y或yarn前缀。</p>
<p>注意：你可以通过设置FLINK_CONF_DIR环境变量来为每个job使用不同的配置目录。<br>使用这个将拷贝来自Flink分布下conf目录，并更新每个job的日志。</p>
<p>注意：组合-m yarn-cluster和隔离YARN会话（-yd）命令可”焚毁和忘掉”提交Flink job在YARN集群中。<br>在此情况下，你的应用程序将得不到任何确认结果或 排除ExecutionEnvironment.execute()的请求消息。</p>
<h2 id="使用jars-amp-Classpath"><a href="#使用jars-amp-Classpath" class="headerlink" title="使用jars&amp;Classpath"></a>使用jars&amp;Classpath</h2><p>默认下，Flink会把用到的jars带进系统路径，当运行一个job时。这个行为可以用yarn.per-job-cluster.include-user-jar<br>参数来控制。</p>
<p>当设置这个参数为DISABLED时，Flink将把用户路径的jars带进。</p>
<p>user-jars在系统路径位置可以通过设置参数来控制：</p>
<ul>
<li>ORDER：默认，按照字典路径顺序添加jar进系统。</li>
<li>FIRST:系统路径最前的添加。</li>
<li>LAST:系统路径最后的添加。</li>
</ul>
<h2 id="Flink在YARN上的恢复行为"><a href="#Flink在YARN上的恢复行为" class="headerlink" title="Flink在YARN上的恢复行为"></a>Flink在YARN上的恢复行为</h2><p>Flink的YARN客户端有如下配置参数来控制行为当容器失败后，这些参数可通过conf/flink-conf.yaml设置，也可以通过<br>在启动YARN会话时用-D参数设置。</p>
<ul>
<li><code>yarn.reallocate-failed</code>: 控制Flink是否重新分配失败的Task Manager。默认true。</li>
<li><code>yarn.maximum-failed-containers</code>: ApplicationMaster接受的最大容器失败个数，直到YARN会话失败。默认是-n设置的Task Manager个数。</li>
<li><code>yarn.application-attempts</code>: ApplicationMaster（+其拥有的Task Manager个数）的尝试次数，默认1，ApplicationMaster失败则YARN会话整个失败。在YARN中指定更大值以便重启ApplicationMaster。</li>
</ul>
<h2 id="调试一个失败的YARN会话"><a href="#调试一个失败的YARN会话" class="headerlink" title="调试一个失败的YARN会话"></a>调试一个失败的YARN会话</h2><p>有很多原因使得一个Flink的YARN会话失败。一个错误的Hadoop安装（HDFS权限，YARN配置），版本兼容（运行Flink在vanilla的Hadoop上，却依赖Cloudera Hadoop）或其他原因。</p>
<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>部署时Flink YARN会话失败，用户必须依靠Hadoop YARN的日志。<br>最有用的是YARN日志集合。用户必须在yarn-site.xml文件中把yarn.log-aggregation-enable参数值设置为true，<br>使其生效。只要它一经生效，用户可以使用如下命令来检索一个（失败）yarn会话的所有日志文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn logs -applicationId &lt;application ID&gt;</div></pre></td></tr></table></figure>
<p>在会话结束时请等待几秒钟直到日志展示出来。</p>
<h3 id="YARN客户端控制台-amp-web接口"><a href="#YARN客户端控制台-amp-web接口" class="headerlink" title="YARN客户端控制台&amp;web接口"></a>YARN客户端控制台&amp;web接口</h3><p>Flink YARN客户端也可以在终端输出错误信息，如果在运行时出错（如某时间Task Manager停止工作）.此外，有YARN资源管理器的web接口（默认是8088端口），这个资源管理器web接口的端口由<br>yarn.resourcemanager.webapp.address参数值决定。</p>
<p>在web页面可访问运行YARN应用程序的日志文件并可显示失败应用程序的诊断信息。</p>
<h2 id="为指定Hadoop版本构建YARN客户端"><a href="#为指定Hadoop版本构建YARN客户端" class="headerlink" title="为指定Hadoop版本构建YARN客户端"></a>为指定Hadoop版本构建YARN客户端</h2><p>用户使用像Hortonworks, Cloudera or MapR等公司发布的Hadoop，它们的Hadoop（HDFS）版本和YARN版本可能与构建Flink冲突，<br>请参考<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.3/setup/building.html" target="_blank" rel="external">构建介绍</a>获得更细介绍。</p>
<h2 id="防火墙后在YARN运行Flink"><a href="#防火墙后在YARN运行Flink" class="headerlink" title="防火墙后在YARN运行Flink"></a>防火墙后在YARN运行Flink</h2><p>一些YARN集群使用防火墙来控制集群和余下网络之间的网络传输，在这种配置下，Flink的job提交到YARN会话中只能通过集群网络（在防火墙背后），<br>如果在生产环境下不可行，Flink允许配置一定范围的端口给相关服务，<br>在这些范围配置下，用户可以跨越防火墙提交job到Flink。</p>
<p>当前，有两个服务需要提交job:</p>
<ul>
<li>Job Manager（YARN上的ApplicationMaster）</li>
<li>运行Job Manager的BlobServer</li>
</ul>
<p>当提交一个job到Flink，BlobServer将会分发用户代码中的jars给所有工作节点（Task Manager），<br>Job Manager接收job本身并触发执行。</p>
<p>以下两个配置参数可指定端口:</p>
<ul>
<li><code>yarn.application-master.port</code></li>
<li><code>blob.server.port</code></li>
</ul>
<p>这两个配置可接收单个端口值（如50010），也可以接收范围（50000-50025），或者<br>组合（50010,50011,50020-50025,50050-50075）</p>
<p>（Hadoop使用同样的机制，配置参数是yarn.app.mapreduce.am.job.client.port-range）</p>
<h2 id="背后-内部"><a href="#背后-内部" class="headerlink" title="背后/内部"></a>背后/内部</h2><p>本小节简要描述Flink和YARN如何交互.</p>
<p><img src="/fig/FlinkOnYarn.svg" class="img-responsive"></p>
<p>YARN客户端需要访问Hadoop的配置以连接YARN资源管理器和HDFS,这决定了Hadoop配置采取如下策略，</p>
<ul>
<li>测试YARN_CONF_DIR, HADOOP_CONF_DIR or HADOOP_CONF_PATH （按此顺序）是否已配置，其中一个配置了，它们就可以读取到配置。</li>
<li>如若上述策略失败（正确的YARN安装不会出现此情况），客户端使用HADOOP_HOME环境变量。如环境变量设置了，客户端会尝试访问$HADOOP_HOME/etc/hadoop（hadoop2.<em>）或 $HADOOP_HOME/conf（hadoop1.</em>）</li>
</ul>
<p>当启动一个新的Flink YARN会话，客户端会先确认请求的资源（容器和内存）是否能获得到。<br>之后，客户端上传包含Flink和HDFS配置的jars（步骤1）。</p>
<p>下一步客户端请求一个YARN容器（步骤2）来启动ApplicationMaster（步骤3），<br>客户端注册了配置和容器资源的jar文件，指定机器运行的YARN节点管理器会准备好容器（下载文件），<br>这些结束了，ApplicationMaster (AM)就启动了。</p>
<p>Job Manager和AM运行在同一个容器里，它们成功启动后，AM知道job管理器（它拥有的主机）的地址。</p>
<p>Job Manager为Task Manager生成一个新的Flink配置（这样task可连接Job Manager）。</p>
<p>文件也上传到HDFS上。另外AM容器也为Flink的web接口服务。YARN代码的所有端口是分配的临时端口。<br>这可让用户并行执行多个yarn会话。</p>
<p>然后，AM启动分配到的容器，这些容器给Flink的Task Manager，将会下载jar和更新来自HDFS配置<br>，这些步骤完成后，Flink就安装起来了，可以接收job了。</p>
<h2 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h2><p>1，Flink的流job运行，会提交的终端一直保持执行，如果想在后台运行，可使用supervior监控执行的进程，这样不会在终端显示运行，另外，job报错也会自动再次提交运行；</p>
<p>2，Flink的job提交YARN集群执行时，建议把参数-yd带上，即断开提交客户端与YARN集群的通信。如果不加-yd参数，会在提交job的机器上占用很大内存保持job在YARN上的通信，造成机器资源占用。断开连接后怎么保持job的可靠性，即失败时可自动提交，这功能可在Flink的job代码中配置<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/restart_strategies.html" target="_blank" rel="external">重启策略</a>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">1,失败后尝试重启动策略</div><div class="line"></div><div class="line">在失败后,尝试重启动3次,每次间隔10秒;如果尝试3次后,job还是失败,则不再重启,宣告job失败;不是立刻执行重启,而是延迟固定时间,这是为了让底层有时间准备好环境,比如外部系统连接.</div><div class="line"></div><div class="line">import org.apache.flink.api.common.time.Time</div><div class="line">import java.util.concurrent.TimeUnit</div><div class="line">import org.apache.flink.api.common.restartstrategy.RestartStrategies</div><div class="line"></div><div class="line">val env = ExecutionEnvironment.getExecutionEnvironment()</div><div class="line">env.setRestartStrategy(RestartStrategies.fixedDelayRestart(</div><div class="line">  3, // number of restart attempts</div><div class="line">  Time.of(10, TimeUnit.SECONDS) // delay</div><div class="line">))</div><div class="line"></div><div class="line">2,失败率重启策略</div><div class="line"></div><div class="line">在一定时间段内重启失败率太高,则宣告job失败;在两个尝试策略下,会等待一定时间.</div><div class="line"></div><div class="line">时间间隔内尝试重启job的次数;</div><div class="line">时间间隔多长;</div><div class="line">两次重启间的延迟时长;</div><div class="line"></div><div class="line">val env = ExecutionEnvironment.getExecutionEnvironment()</div><div class="line">env.setRestartStrategy(RestartStrategies.failureRateRestart(</div><div class="line">  3, // max failures per unit</div><div class="line">  Time.of(5, TimeUnit.MINUTES), //time interval <span class="keyword">for</span> measuring failure rate</div><div class="line">  Time.of(10, TimeUnit.SECONDS) // delay</div><div class="line">))</div></pre></td></tr></table></figure>
<p>3,Flink的新版本，最好在assembly项目时把包到带上，虽然包很大，但是为了YARN的其他开源版本兼容，建议使用程序的包。这样提交运行时不用–classpath带上包。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chlyzzo.github.io/2017/05/19/flink学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wenxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山上掏金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/19/flink学习/" itemprop="url">Flink学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-19T22:46:57+08:00">
                2017-05-19 22:46:57
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flink/" itemprop="url" rel="index">
                    <span itemprop="name">Flink</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>讲述flink在实践中的一些经验，对入门级的有一定的认识;<br>flink的窗口，提交运行的命令含义，参数传递，函数重新编写，向量计算，读取csv文件等；<br>主要是一些实践的笔记，比较粗略，后续再考虑逐步细写下，分成更多的小点。</p>
<p>首先从统计单词出发，这个统计是实时接收socket的消息来统计的，需要一个窗口，这里设定为每隔5秒统计一次；</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class WindowWordCount &#123;</div><div class="line">       public static void main(String[] args) throws Exception &#123;</div><div class="line">                StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</div><div class="line">                DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; dataStream = env</div><div class="line">                .socketTextStream(&quot;localhost&quot;, 9999)</div><div class="line">                .flatMap(new Splitter())</div><div class="line">                .keyBy(0)</div><div class="line">                .timeWindow(Time.of(5, TimeUnit.SECONDS))</div><div class="line">                .sum(1);</div><div class="line"></div><div class="line">        dataStream.print();</div><div class="line">        env.execute(&quot;Window WordCount&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static class Splitter implements FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt; &#123;</div><div class="line">        @Override</div><div class="line">        public void flatMap(String sentence, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out) throws Exception &#123;</div><div class="line">            for (String word: sentence.split(&quot; &quot;)) &#123;</div><div class="line">                out.collect(new Tuple2&lt;String, Integer&gt;(word, 1));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>new Splitter()和Splitter implements FlatMapFunction<string, tuple2<string,="" integer="">&gt;</string,></p>
<h2 id="flink-下datastrema的window操作"><a href="#flink-下datastrema的window操作" class="headerlink" title="flink 下datastrema的window操作"></a>flink 下datastrema的window操作</h2><p>可以参考<a href="https://ci.apache.org/projects/flink/flink-docs-release-0.10/apis/streaming_guide.html#working-with-time" target="_blank" rel="external">这个文档</a></p>
<h3 id="flink下的windows的time类型，"><a href="#flink下的windows的time类型，" class="headerlink" title="flink下的windows的time类型，"></a>flink下的windows的time类型，</h3><p>import org.apache.flink.streaming.api.TimeCharacteristic</p>
<ul>
<li><p>processing time，当执行转换算子的时间，分布式和异步下不能满足目的。</p>
<pre><code>env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)
</code></pre></li>
<li><p>event time，事件时间，独立事件的时间，通常是进入到flink前就有了，嵌入在记录里或者内容里</p>
<pre><code>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
时间顺序，无序也能正确处理（需要缓存），有延迟，
</code></pre></li>
<li>Ingestion time，进入到flink的时间，介于前两者之间，<pre><code>env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime)
</code></pre></li>
</ul>
<p>watermark 时间水印，由源发出，没有时间戳的时间</p>
<p>对于事件时间event time，需如下步骤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Set env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</div><div class="line">Use DataStream.assignTimestamps(...) in order to tell Flink how timestamps relate to events </div><div class="line">    (e.g., which record field is the timestamp)，这是记录中包含时间戳的例子，</div><div class="line">Set enableTimestamps(), as well the interval for watermark emission (</div><div class="line">    setAutoWatermarkInterval(long milliseconds)) in ExecutionConfig.</div></pre></td></tr></table></figure></p>
<h2 id="flink下的窗口定义，"><a href="#flink下的窗口定义，" class="headerlink" title="flink下的窗口定义，"></a>flink下的窗口定义，</h2><p>窗口中的元素实际存储在 Key/Value State 中，key为Window，value为元素集合（或聚合值）<br>当一个元素进入流时，<br>    1,根据window决定去哪个窗口;<br>          窗口只是一个标示，不存储数据，也会存时间。<br>    2,每个窗口有一个trigger，决定窗口的生存时间（该窗口计算和清除时间）;<br>           trigger返回continue（等待），fire（处理窗口数据），purge（清除窗口），<br>         如果是fire，则窗口保留，数据一直存在，会被计算多次，直到purge。<br>    3,如果窗口被fire（处理），窗口中的元素指定给evictor，<br>         Evictor 主要用来遍历窗口中的元素列表，并决定最先进入窗口的多少个元素需要被移除。剩余的元素会交给用户指定的函数进行窗口的计算<br>    4,计算函数，经过（window，trigger，evictor），接收到窗口元素，计算其中元素，返回给下游，<br>       计算值可返回多个或一个，计算函数有max，min，基于WindowFunction实现的。。<br>（注意，evictor需要对窗口内所有元素保留，除了聚合sum，min只需保留最后值，）</p>
<h2 id="WindowedStream"><a href="#WindowedStream" class="headerlink" title="WindowedStream"></a>WindowedStream</h2><p>其中 T 数据流中元素的数据类型<br>K 是元素的key的类型<br>W是窗口类型<br>R 初始值（fold时用到）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">apply (6个apply方法)  (k : Long, w : TimeWindow, T: Iterable[(Long, Long, Long)], out : Collector[(Long,String,String,Double)])</div><div class="line"></div><div class="line">     apply(WindowFunction&lt;T, R, K, W&gt; function)</div><div class="line">         </div><div class="line">     apply(WindowFunction&lt;T, R, K, W&gt; function, TypeInformation&lt;R&gt; resultType)</div><div class="line"></div><div class="line">     apply(ReduceFunction&lt;T&gt; reduceFunction, WindowFunction&lt;T, R, K, W&gt; function)</div><div class="line">     apply(ReduceFunction&lt;T&gt; reduceFunction, WindowFunction&lt;T, R, K, W&gt; function, TypeInformation&lt;R&gt; resultType)</div><div class="line">     </div><div class="line">     apply(R initialValue, FoldFunction&lt;T, R&gt; foldFunction, WindowFunction&lt;R, R, K, W&gt; function)</div><div class="line">     apply(R initialValue, FoldFunction&lt;T, R&gt; foldFunction, WindowFunction&lt;R, R, K, W&gt; function, TypeInformation&lt;R&gt; resultType)</div></pre></td></tr></table></figure></p>
<p><a href="https://m.aliyun.com/yunqi/articles/57828" target="_blank" rel="external">Blink 阿里</a></p>
<p>you can rely on the RichFunction’s open() method’s to load such data directly from a distributed file system.<br>DataStream没有DistributedCache,但是可以在RichFunction’s open() 方法中读取分布式存储的文件…</p>
<h2 id="flink运行的参数意义"><a href="#flink运行的参数意义" class="headerlink" title="flink运行的参数意义,"></a>flink运行的参数意义,</h2><p>目前用到:flink 提交yarn集群的<a href="https://ci.apache.org/projects/flink/flink-docs-master/setup/cli.html" target="_blank" rel="external">参数</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-yn,--yarncontainer &lt;arg&gt;            Number of YARN container to allocate(=Number of Task Managers)</div><div class="line"></div><div class="line">-ys,--yarnslots &lt;arg&gt;                Number of slots per TaskManager</div><div class="line"></div><div class="line">-yjm,--yarnjobManagerMemory &lt;arg&gt;    Memory for JobManager Container [inMB]</div><div class="line"></div><div class="line">-ytm,--yarntaskManagerMemory &lt;arg&gt;   Memory per TaskManager Container [inMB]</div></pre></td></tr></table></figure>
<p>yn是taskmanager的个数,即worker的个数,ys是slot个数,即每个taskmanager由几个slot来计算,<br>yjm,<br>ytm,每一个taskmanager内存大小,</p>
<h2 id="flink架构重新学习"><a href="#flink架构重新学习" class="headerlink" title="flink架构重新学习"></a><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.0/concepts/concepts.html#parallel-dataflows" target="_blank" rel="external">flink架构重新学习</a></h2><p>flink的数据块是流,dataset也是流,特殊的流,开始一个或多个源,结束一个或多个sinks,一个转换有多个转换算子组成…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">流的运算流程是,source-&gt; </div><div class="line">                         transformation(flatmap,map,....算子operators)-&gt; </div><div class="line">                                          ...-&gt; </div><div class="line">                                                 transformation(flatmap,map,....算子operators)-&gt;</div><div class="line">                                                            sink</div></pre></td></tr></table></figure>
<p>并行度（一个task被split的并行实例个数），可以在不同层级上设定;<br>   一个task可split多个并行实例，一个实例处理inputData的子集，（实例处理子集，有合并没？）</p>
<h3 id="并行是怎么操作的"><a href="#并行是怎么操作的" class="headerlink" title="并行是怎么操作的?"></a>并行是怎么操作的?</h3><p>  分布式和并行下,数据是分区的,操作也变成操作subtask,(操作subtask是独立隔离的,不同线程,不同机器,不同containers)<br>  操作subtask的个数是并行度,parallelism,由算子operators决定,一个程序会有多个并行,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">--&gt;    ---&gt;     ---&gt;</div><div class="line">             x        y  --&gt;sink</div><div class="line">--&gt;    ---&gt;     ---&gt;</div></pre></td></tr></table></figure></p>
<p>流在两个operators(算子)之间可以使一对一前行,也可以是再分区前行,<br>相对的是Redistributing,即算子需要对数据进行重新规划,比如keyby,broadcast, rebalance</p>
<p>flink链,chains,把算子连在一起,起到优化作用,</p>
<h2 id="分布式-yarn-集群"><a href="#分布式-yarn-集群" class="headerlink" title="分布式,yarn,集群"></a>分布式,yarn,集群</h2><p>两个操作进程类型,master,JobManagers,协调分布式执行,checkpoint,故障恢复,<br>必须有一个,可以设置多个,一个是主,其他是备用(其中一个挂了,备用是不是可以当作主来重启运行???)<br>worker,TaskManagers,执行task或者执行subtasks,缓冲区,至少有一个,</p>
<p>The master and worker processes开始于集群,容器,或者yarn的资源管理器,</p>
<p>client客户端,不是运行时和程序的部分,准备发送流给master,然后断开或者保持连接等待信息反馈,</p>
<p>Each worker (TaskManager) is a JVM process, and may execute one or more subtasks in separate threads. </p>
<p>To control how many tasks a worker accepts, a worker has so called task slots (at least one).</p>
<p>slot是一个TaskManager可以运行几个task,一个taskTaskManager分配的内存是ytm,<br>每个slot是固定的资源子集,在大集合TaskManager中,也就是slot瓜分TaskManager的资源,而且是平分,<br>每个slot是不同thread执行.</p>
<p>Having one slot per TaskManager means each task group runs in a separate JVM,<br>Having multiple slots means more subtasks share the same JVM,share data sets and data structures..</p>
<p>共享slot,默认的配置,</p>
<p>迭代,大量的计算,大的分布式计算,做法是step-function和嵌入迭代算子(Iterate and Delta Iterate),</p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.0/apis/batch/iterations.html" target="_blank" rel="external">迭代例子</a></p>
<p>只用于dataset???</p>
<p>   1,iterate operator,<br>        1.1 Iteration Input: 初始化数据输入,来源前一个迭代或者前一个算子;<br>        1.2 Step Function: 每一次迭代执行的函数. operators, map, reduce, join, …,<br>        1.3 Next Partial Solution: 下一次迭代的数据,<br>        1.4 Iteration Result: 最后一次迭代,数据输出到sink或者下一个算子,<br>  终止条件,<br>      1,最大迭代次数,自定义的,达到迭代次数,结束,输出结果;<br>      2,自定义聚合和熟练准则,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">val count = initial.iterate(10000) &#123; iterationInput: DataSet[Int] =&gt;</div><div class="line">      val result = iterationInput.map &#123; i =&gt;</div><div class="line">            val x = Math.random()</div><div class="line">            val y = Math.random()</div><div class="line">            i + (if (x * x + y * y &lt; 1) 1 else 0)</div><div class="line">      &#125;</div><div class="line">      result</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>  2,Delta Iterate Operator,<br>     每次迭代会选择部分数据计算,不是全量,适用于高级的算法,或者某些数据不是每次迭代对计算有用,只关注那些频繁和有用于计算的数据,舍弃无用,没计算的数据.<br>    2.1 Iteration Input: 初始化数据输入,来源data source或者前一个算子;<br>    2.2 Step Function: 每一次迭代执行的函数. operators, map, reduce, join, …,<br>    2.3 Next Workset/Update Solution Set: 下一次迭代反馈workset,数据可通过不同算子更新 ,<br>    2.4 Iteration Result: 最后一次迭代,数据输出到sink或者下一个算子,</p>
<p>终止条件,<br>      1,最大迭代次数,自定义的,达到迭代次数,结束,输出结果;<br>      2,下一次迭代workset收敛为0,也就是数据为空.(自定义聚合和收敛准则)</p>
<p>两个数据集,workset和solution,每次迭代得到newworkset和newsolution<br>To create a DeltaIteration call the iterateDelta(initialWorkset, maxIterations, key) on the initial solution set. The step function takes two parameters: (solutionSet, workset), and must return two values: (solutionSetDelta, newWorkset).</p>
<p>ParameterTool 整合参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">env.readCsvFile[Point](</div><div class="line">       params.get(&quot;points&quot;),</div><div class="line">       fieldDelimiter = &quot; &quot;,</div><div class="line">       includedFields = Array(0, 1))</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>flink下的functions<br>single abstract method  单一的抽象方法,</p>
<p>1,coGroup(Iterable<in1> first, Iterable<in2> second, Collector<o> out)</o></in2></in1></p>
<pre><code>  set1.coGroup(set2).where(&lt;key-definition&gt;).equalTo(&lt;key-definition&gt;).with(new MyCoGroupFunction());

注意,first:java.lang.Iterable[Int],
    然后,计算时,采取用
import scala.collection.JavaConverters._
val scalaT2 = first.asScala.toList
</code></pre><p> 2,CombineFunction<in, out=""><br>         把元素组合并返回,</in,></p>
<h2 id="非常好的解读flink下的函数和参数"><a href="#非常好的解读flink下的函数和参数" class="headerlink" title="非常好的解读flink下的函数和参数"></a>非常好的解读flink下的函数和参数</h2><p><a href="http://www.cnblogs.com/fxjwind/p/5168785.html" target="_blank" rel="external">链接1</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-0.10/apis/programming_guide.html" target="_blank" rel="external">链接2</a></p>
<p>1,使用Rich functions</p>
<p>Rich functions provide, in addition to the user-defined function (map, reduce, etc), four methods: open, close, getRuntimeContext, and setRuntimeContext.</p>
<p>Rich functions的使用和普通的function是一样的，不同的就是，多4个接口函数，可以用于一些特殊的场景，比如给function传参，或访问broadcast变量，accumulators和counter，因为这些场景你需要先getRuntimeContext</p>
<p>2,Broadcast Variables<br>一个算子中在并行实例下可以访问到数据,广播data set的结构是collection,<br>withBroadcastSet(DataSet, String)广播一个dataset<br>getRuntimeContext().getBroadcastVariable(String) at the target operator.访问广播的data set;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1. The DataSet to be broadcasted</div><div class="line">  DataSet&lt;Integer&gt; toBroadcast = env.fromElements(1, 2, 3);</div><div class="line"></div><div class="line">  DataSet&lt;String&gt; data = env.fromElements(&quot;a&quot;, &quot;b&quot;);</div><div class="line"></div><div class="line"> data.map(new RichMapFunction&lt;String, String&gt;() &#123;</div><div class="line">  @Override</div><div class="line">  public void open(Configuration parameters) throws Exception &#123; //open方法会被启用一次,</div><div class="line">    // 3. Access the broadcasted DataSet as a Collection</div><div class="line">    Collection&lt;Integer&gt; broadcastSet = getRuntimeContext().getBroadcastVariable(&quot;broadcastSetName&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  @Override //map调用的次数是data中的元素个数,</div><div class="line">  public String map(String value) throws Exception &#123;</div><div class="line">      ...</div><div class="line">  &#125;</div><div class="line"> &#125;).withBroadcastSet(toBroadcast, &quot;broadcastSetName&quot;); // 2. Broadcast the DataSet</div></pre></td></tr></table></figure>
<p>广播数据集，就是有些不大的公共数据，是要被所有的实例访问到的，比如一些查询表,(不大的公共数据)<br>上面的例子，会将toBroadcast设置为广播变量broadcastSetName，这样在运行时，可以用getRuntimeContext().getBroadcastVariable获取该变量使用</p>
<h2 id="参数传递-在构造函数中使用"><a href="#参数传递-在构造函数中使用" class="headerlink" title="参数传递,在构造函数中使用"></a>参数传递,在构造函数中使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static class MyFilter implements FilterFunction&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">  private final int limit; //参数</div><div class="line"></div><div class="line">  public MyFilter(int limit) &#123;//构造函数</div><div class="line">    this.limit = limit;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public boolean filter(Integer value) throws Exception &#123;</div><div class="line">    return value &gt; limit;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用withParameters-Configuration"><a href="#使用withParameters-Configuration" class="headerlink" title="使用withParameters(Configuration)"></a>使用withParameters(Configuration)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Configuration config = new Configuration();</div><div class="line">config.setInteger(&quot;limit&quot;, 2);</div><div class="line"></div><div class="line">toFilter.filter(new RichFilterFunction&lt;Integer&gt;() &#123;</div><div class="line">    private int limit;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void open(Configuration parameters) throws Exception &#123;</div><div class="line">      limit = parameters.getInteger(&quot;limit&quot;, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean filter(Integer value) throws Exception &#123;</div><div class="line">      return value &gt; limit;</div><div class="line">    &#125;</div><div class="line">&#125;).withParameters(config);</div></pre></td></tr></table></figure>
<p>可以用withParameters将定义好的config传入function</p>
<p>然后用RichFunction的Open接口，将参数解析出来使用</p>
<hr>
<h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><p>  (全局参数只能用于参数形式，广播变量可以是任意dataset),但是全局参数,可用于更大的数据集,比如几百万的表数据,广播的话<br>花费就大.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Configuration conf = new Configuration();</div><div class="line">conf.setString(&quot;mykey&quot;,&quot;myvalue&quot;);</div><div class="line">final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</div><div class="line">env.getConfig().setGlobalJobParameters(conf);</div><div class="line"></div><div class="line"></div><div class="line">public static final class Tokenizer extends RichFlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt; &#123;</div><div class="line"></div><div class="line">    private String mykey;</div><div class="line">    @Override</div><div class="line">    public void open(Configuration parameters) throws Exception &#123;</div><div class="line">      super.open(parameters);</div><div class="line">      ExecutionConfig.GlobalJobParameters globalParams = getRuntimeContext().getExecutionConfig().getGlobalJobParameters();</div><div class="line">      Configuration globConf = (Configuration) globalParams;</div><div class="line">      mykey = globConf.getString(&quot;mykey&quot;, null);</div><div class="line">    &#125;</div><div class="line">    // ... more here ...</div></pre></td></tr></table></figure></p>
<h2 id="richfunction的使用"><a href="#richfunction的使用" class="headerlink" title="richfunction的使用"></a>richfunction的使用</h2><p>Rich functions的使用和普通的function是一样的，不同的就是，多4个接口函数，可以用于一些特殊的场景，比如给function传参，或访问broadcast变量，accumulators和counter，因为这些场景你需要先getRuntimeContext,</p>
<p>four methods: open, close, getRuntimeContext, and setRuntimeContext.</p>
<h2 id="state的使用"><a href="#state的使用" class="headerlink" title="state的使用"></a>state的使用</h2><pre><code>Key/Value state 只能用于KeyedStream,
3种不同类型的state，

ValueState，单值的state，可以通过update(T)或T value()来操作

ListState&lt;T&gt;， 多值的state，通过add(T)或Iterable&lt;T&gt; get()来操作和访问
  访问当前存储的元素,
ReducingState&lt;T&gt;，多值状态，但是只保留reduce的结果
    聚集的单个元素,

并且所有的state，都有clear，来清除状态数据
</code></pre><p>这些state对象只能被状态接口使用，<br>并且取出的状态对象，取决于input element的key；所以不同的调用user function 得到的state value是不一样的，因为element的key 可能不同</p>
<p>对于state，需要一个StateDescriptor ，作为name用于reference这个state，如果你定义多个state，他们的StateDescriptor 必须是unique的。<br>不同类型的state，有不同类型的StateDescriptor</p>
<p>ValueState<t> getState(ValueStateDescriptor<t>)<br>ReducingState<t> getReducingState(ReducingStateDescriptor<t>)<br>ListState<t> getListState(ListStateDescriptor<t>)</t></t></t></t></t></t></p>
<p>State对象通过RuntimeContext的接口获取到，当然不同类型的state，对应于不同的接口；<br>关键是，如果要使用state，必须要使用rich function，用普通的function是无法获取到的</p>
<p><a href="http://blog.csdn.net/lmalds/article/details/52229827" target="_blank" rel="external">http://blog.csdn.net/lmalds/article/details/52229827</a><br>ListState的使用<br><a href="http://blog.csdn.net/codemosi/article/details/51602204" target="_blank" rel="external">http://blog.csdn.net/codemosi/article/details/51602204</a><br>三种state的使用,</p>
<h2 id="flink-下的向量-矩阵计算"><a href="#flink-下的向量-矩阵计算" class="headerlink" title="flink 下的向量,矩阵计算"></a>flink 下的向量,矩阵计算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">引入包,</div><div class="line"></div><div class="line">(&quot;org.apache.flink&quot; %% &quot;flink-ml&quot; % flinkVersion).</div><div class="line">                  exclude(&quot;org.apache.flink&quot;,&quot;flink-shaded-hadoop1_2.10&quot;),</div><div class="line"></div><div class="line">import org.apache.flink.ml.math.Vector</div><div class="line">import org.apache.flink.ml.math.VectorBuilder</div><div class="line">import org.apache.flink.ml.math.DenseVector</div><div class="line"></div><div class="line">val vec1 = &quot;12.3,45,55&quot;.split(&quot;,&quot;).map(_.toDouble)</div><div class="line">val flinkVec1 = DenseVector.apply(vec1)</div><div class="line">val vec2 = &quot;12.3,45,55&quot;.split(&quot;,&quot;).map(_.toDouble)</div><div class="line">val flinkVec2 = DenseVector.apply(vec2)</div><div class="line">    </div><div class="line">println(flinkVec1.dot(flinkVec2))</div></pre></td></tr></table></figure>
<p><a href="http://data-artisans.com/extending-the-yahoo-streaming-benchmark/" target="_blank" rel="external">推特的</a></p>
<p><a href="https://yahooeng.tumblr.com/post/135321837876/benchmarking-streaming-computation-engines-at" target="_blank" rel="external">雅虎的</a></p>
<p><a href="http://flink-forward.org/category/news/" target="_blank" rel="external">2015flink会议</a></p>
<p>使用 <code>RichGroupReduceFunction</code> 实现<code>GroupCombineFunction</code> interface,<br>在shuffle前combining,减少网络负载;<br>另外,reduce实现reduceGroup也可以提高性能,<br>结果再次使用<code>.setCombineHint(CombineHint.HASH)</code> after the reduce.</p>
<h2 id="flink-读取csv文件的参数含义"><a href="#flink-读取csv文件的参数含义" class="headerlink" title="flink 读取csv文件的参数含义,"></a>flink 读取csv文件的参数含义,</h2><p>val csvInput = env.readCsvFile<a href="&quot;hdfs:///the/CSV/file&quot;,
  includedFields = Array(0, 3">(String, Double)</a>) // take the first and the fourth field</p>
<p>lineDelimiter: 行与行之间的分隔符,默认是’\n’.</p>
<p>fieldDelimiter: 每行数据间的分隔符,默认是 ‘,’.</p>
<p>includeFields: Array[Int] 需要过滤的字段,也就是每行分割所要留下的哪几列.</p>
<p>pojoFields: Array[String] 对象实例所要留下的字段.</p>
<p>parseQuotedStrings: Character enables quoted string parsing. Strings are parsed as quoted strings if the first character of the string field is the quote character (leading or tailing whitespaces are not trimmed). Field delimiters within quoted strings are ignored. Quoted string parsing fails if the last character of a quoted string field is not the quote character. If quoted string parsing is enabled and the first character of the field is not the quoting string, the string is parsed as unquoted string. By default, quoted string parsing is disabled.</p>
<p>ignoreComments: String specifies a comment prefix. All lines that start with the specified comment prefix are not parsed and ignored. By default, no lines are ignored.</p>
<p>lenient: Boolean enables lenient parsing, i.e., lines that cannot be correctly parsed are ignored. By default, lenient parsing is disabled and invalid lines raise an exception.</p>
<p>ignoreFirstLine: 是否忽略第一行,因为第一行有时是为了解释用的.</p>
<h2 id="遍历目录下的所有文件"><a href="#遍历目录下的所有文件" class="headerlink" title="遍历目录下的所有文件,"></a>遍历目录下的所有文件,</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// enable recursive enumeration of nested input files</div><div class="line">val env  = ExecutionEnvironment.getExecutionEnvironment</div><div class="line"></div><div class="line">// create a configuration object</div><div class="line">val parameters = new Configuration</div><div class="line"></div><div class="line">// set the recursive enumeration parameter</div><div class="line">parameters.setBoolean(&quot;recursive.file.enumeration&quot;, true) //将递归遍历目录设置为true</div><div class="line"></div><div class="line">// pass the configuration to the data source</div><div class="line">env.readTextFile(&quot;file:///path/with.nested/files&quot;).withParameters(parameters)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chlyzzo.github.io/2017/05/18/hive笛卡尔积优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wenxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山上掏金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/hive笛卡尔积优化/" itemprop="url">hive笛卡尔积优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-18T18:47:17+08:00">
                2017-05-18 18:47:17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hive/" itemprop="url" rel="index">
                    <span itemprop="name">hive</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="hive的笛卡尔积"><a href="#hive的笛卡尔积" class="headerlink" title="hive的笛卡尔积"></a>hive的笛卡尔积</h2><p>hive中默认不使用笛卡尔积，需要开启才能运行，hive不建议运行笛卡尔积，但是，在实践过程中，难免需要使用到，这时就得开启该功能；然后，hive中做笛卡尔积的结果就是最后的数据运算都集中在一个reduce上，亲测确实如此。那么，该怎么优化呢？</p>
<h2 id="优化历程"><a href="#优化历程" class="headerlink" title="优化历程"></a>优化历程</h2><p>笛卡尔积计算需要把数据全部遍历一遍才行，使用笛卡尔积理论上数据需要保存进内存，如果有多个任务运行，那么就得把数据复制多份，然而实时却并非如此；因为，笛卡尔积的计算最终是计算出结果，因此，会把数据积压到一个reduce上，而不是多份（虽然难以理解，但是，实践测试多次，还真心如此）。<br>因此，想要优化，必须加大reduce的个数，这时需要有分区（或者分块）的概念，即把数据copy成多份，进行join操作，在计算时把小部分数据与全部数据进行join，达到笛卡尔积的效果。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>1，获得表a<br>2，copya表成b，注意是拓展的copy，即分区成5份（看资源情况可设置成更多份）：  </p>
<p>drop table if exists b;<br>create table b<br>as<br>select <em> from<br>(<br>select aa.</em>,’1,2,3,4,5’ as old_part  a aa<br>)b lateral view explode(split(old_part,’,’)) b as part<br>;</p>
<p>3,把表a的记录进行随机打散：</p>
<p>drop table if exists aa;<br>create table aa<br>as<br>select aaa.<em><br>       ,cast(round(rand()</em>4+1.0,0) as int) as part from  a aaa<br>;</p>
<p>4,做一般的join操作</p>
<p>drop table if exists aab;<br>create table aab<br>as<br>select<br>   a.id<br>   ,b.id as id_tj<br>from aa a<br>join b b<br>on a.part=b.part<br>;</p>
<p>5，这样就可5个reduce计算，比单独的一个reduce快的多</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>1, hive是分布式计算结构化数据的一个工具，本质上使用map-reduce计算框架；<br>2，hive操作与mysql类似，但有不同，比如表的in操作等；<br>3，使用map-reduce计算的方式，都需要考虑并行和分区概念。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>分享即是收获，动手后才是自己的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chlyzzo.github.io/2017/05/01/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wenxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山上掏金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/01/hello-world/" itemprop="url">开始搭建-hexo-git-blog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-01T17:14:13+08:00">
                2017-05-01 17:14:13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>“从git起，使用hexo搭建自己的博客，git上传各种资料方便快捷。”</p>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1,安装git，确保在cmd下可以git --version出版本，关键配置好环境变量；</div><div class="line">2，安装hexo，百度搜索出，到官网下载自己的版本</div></pre></td></tr></table></figure>
<p>##配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，在github上注册自己的账号，会得到一个用户名（yourname）；</div><div class="line">2，新建repository，把名字取为yourname.github.io，注意这里的yourname与注册的git账号用户名必须保持一致；</div><div class="line">3，这是在你的git下会有有一个子目录，yourname.github.io，点击进去，查看setting，在GitHub Pages那块不会出现site，不用急；</div></pre></td></tr></table></figure></p>
<p>##命令行搭建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1，在自己本地机器上新建一个目录，dir</div><div class="line">2，cmd进入该目录，然后输入：</div><div class="line">   2.1 hexo init</div><div class="line">   2.2 npm install</div><div class="line">   2.3 hexo g</div><div class="line">   2.4 hexo s</div><div class="line">3,在本地机器上输入网址http://0.0.0.0:4000/，将看到默认的网页，即你的博客样子，当然后续可以自定义修改板式。</div></pre></td></tr></table></figure></p>
<p>##构建自己的博客<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1,修改默认的格式，在dir目录下，有个_config.yml，修改#site下的内容</div><div class="line">2，在#deployment下增加内容</div><div class="line">    deploy:</div><div class="line">      type: git</div><div class="line">      repository: git@github.com:yourname/yourname.github.io.git</div><div class="line">      branch: master</div><div class="line">3，进入到dir目录</div><div class="line">   3.1 运行命令npm install hexo-deployer-git -save</div><div class="line">   3.2 运行命令hexo d -g</div><div class="line">   3.3 在网页输入网址https://yourname.github.io/，即查看到自己的博客样式。</div></pre></td></tr></table></figure></p>
<p>##新增文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1，命令格式，hexo new post &quot;&quot;</div><div class="line">2，在dir目录的source/_posts下自定义filename.md，必须有固定格式</div><div class="line">3，板式在dir目录的thems下修改</div><div class="line">4,在cmd下运行比较靠谱点，安装git后，会有git bash，尽量不在这里运行</div><div class="line">5，git 需要ssh key，这个可以参考http://blog.csdn.net/gdutxiaoxu/article/details/53573399</div><div class="line">6,涉及到中文，最好把文件转为utf格式，不然显示乱码。</div></pre></td></tr></table></figure></p>
<p>##最后的话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">分享即是收获，动手后才是自己的。</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="wenxi" />
          <p class="site-author-name" itemprop="name">wenxi</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/chlyzzo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/longshenfeiyang" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wenxi</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
